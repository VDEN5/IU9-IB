(define call-cc call-with-current-continuation)
(define point #f)
(define (use-assertions)(call-cc (lambda (cc) (set! point cc))))
(define-syntax assert
  (syntax-rules ()
    ((assert ysl) (if (not ysl)
                      ((begin (display "FAILED: ")(write 'expr)(newline))
                       (point))))))
(use-assertions)
(define (1/x x)(assert (not (zero? x)))(/ 1 x))

(define (save-data data file)
  (with-output-to-file file (lambda () (begin (write data) (newline)))))
(define (load-data file)
  (with-input-from-file file (lambda () (begin
                                          (let ((str (read)))
                                            str)))))
(define (count-lines file)
  (with-input-from-file file
    (lambda ()
      (let loop ((prev_str #f) (count 1))
        (let ((str (read-char)))
          (cond ((eof-object? str) count)
                ((and (not(equal? prev_str #\newline)) (equal? #\newline str)) (loop str (+ 1 count)))
                (else (loop str count))))))))
(define (trib n)
  (cond ((<= n 1) 0)((= n 2) 1)
        (else (+ (trib (- n 1)) (trib (- n 2)) (trib (- n 3))))))
(define (tribmemo n)
  (let ((memo (make-vector n 'empty)))
    (let loop ((i n))
      (cond ((<= i 1) 0)((= i 2) 1)
            (else (if (equal? (vector-ref memo (- i 1)) 'empty)
                      (vector-set! memo  (- i 1) (+ (loop (- i 1))(loop (- i 2))(loop (- i 3)))))
                  (vector-ref memo (- i 1)))))))
(define-syntax my-if
  (syntax-rules ()
    ((my-if usl true-branch false-branch)
     (let ((true-promise (delay true-branch))
           (false-promise (delay false-branch)))
       (force (or (and usl true-promise) false-promise))))))
(define-syntax my-let
  (syntax-rules ()
    ((my-let ((var val)) oper) ((lambda (var) oper) val))
    ((my-let ((var val) . li) oper) (my-let li ((lambda (var) oper) val)))))
(define-syntax my-let*
  (syntax-rules ()
    ((my-let* ((var val)) oper) ((lambda (var) oper) val))
    ((my-let* ((var val) . xs) oper) (my-let ((var val))
                                             (my-let* (xs) oper)))))
(define (f1 x y)(my-let ((a x)(b y)) (+ (* a 100) b)))
(save-data '(1 2 3 4) "1234.txt")
(apply * (load-data "1234.txt"))